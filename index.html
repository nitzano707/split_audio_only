<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Splitter</title>
</head>
<body>
    <h1>פיצול קובץ אודיו</h1>
    <input type="file" id="audioFile" accept="audio/*">
    <label for="segments">מספר חלקים:</label>
    <input type="number" id="segments" value="2" min="1">
    <button onclick="splitAudio()">פצל קובץ</button>

    <div id="results"></div>

    <script>
        async function splitAudio() {
            const fileInput = document.getElementById('audioFile').files[0];
            const segments = parseInt(document.getElementById('segments').value);
            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            if (!fileInput || segments < 1) {
                alert("אנא בחר קובץ אודיו והכנס מספר חלקים חוקי.");
                return;
            }

            console.log("קובץ אודיו נבחר:", fileInput.name);
            console.log("מספר החלקים:", segments);

            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await fileInput.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                console.log("משך האודיו:", audioBuffer.duration, "שניות");
                const segmentDuration = audioBuffer.duration / segments;
                console.log("משך כל חלק:", segmentDuration, "שניות");

                for (let i = 0; i < segments; i++) {
                    const start = i * segmentDuration;
                    const end = (i + 1) * segmentDuration;
                    console.log(`פיצול חלק ${i + 1}: התחלה ב-${start} שניות, סיום ב-${end} שניות`);

                    const offlineContext = new OfflineAudioContext(
                        audioBuffer.numberOfChannels,
                        (end - start) * audioBuffer.sampleRate,
                        audioBuffer.sampleRate
                    );

                    const source = offlineContext.createBufferSource();
                    source.buffer = audioBuffer;

                    source.connect(offlineContext.destination);
                    source.start(0, start, end - start);

                    offlineContext.oncomplete = async (e) => {
                        console.log(`חלק ${i + 1} הסתיים בהצלחה.`);
                        const audioBlob = await audioBufferToBlob(e.renderedBuffer);
                        const url = URL.createObjectURL(audioBlob);

                        const audioElement = document.createElement('audio');
                        audioElement.controls = true;
                        audioElement.src = url;

                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = `audio_segment_${i + 1}.wav`;
                        downloadLink.innerText = `הורד חלק ${i + 1}`;

                        resultsContainer.appendChild(audioElement);
                        resultsContainer.appendChild(downloadLink);
                        resultsContainer.appendChild(document.createElement('br'));
                    };

                    await offlineContext.startRendering();
                }
            } catch (error) {
                console.error("שגיאה במהלך פיצול קובץ האודיו:", error);
                alert("אירעה שגיאה במהלך פיצול קובץ האודיו. בדוק את המסוף לפרטים.");
            }
        }

        function audioBufferToBlob(buffer) {
            console.log("התחלה של המרה ל-BLOB...");
            return new Promise((resolve) => {
                const worker = new Worker(URL.createObjectURL(new Blob([`
                    onmessage = async function (e) {
                        const audioBuffer = e.data.buffer;
                        const numChannels = audioBuffer.numberOfChannels;
                        const length = audioBuffer.length;
                        const sampleRate = audioBuffer.sampleRate;

                        let wav = new Uint8Array(44 + length * 2);
                        let view = new DataView(wav.buffer);

                        view.setUint32(0, 0x46464952, false); // "RIFF"
                        view.setUint32(4, 36 + length * 2, true);
                        view.setUint32(8, 0x45564157, false); // "WAVE"
                        view.setUint32(12, 0x20746d66, false); // "fmt "
                        view.setUint32(16, 16, true);
                        view.setUint16(20, 1, true);
                        view.setUint16(22, numChannels, true);
                        view.setUint32(24, sampleRate, true);
                        view.setUint32(28, sampleRate * numChannels * 2, true);
                        view.setUint16(32, numChannels * 2, true);
                        view.setUint16(34, 16, true);
                        view.setUint32(36, 0x61746164, false); // "data"
                        view.setUint32(40, length * 2, true);

                        for (let i = 0; i < length; i++) {
                            for (let ch = 0; ch < numChannels; ch++) {
                                const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(ch)[i]));
                                view.setInt16(44 + (i * numChannels + ch) * 2, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                            }
                        }

                        postMessage(new Blob([wav], { type: "audio/wav" }));
                    };
                `])));

                worker.onmessage = function (e) {
                    console.log("המרה ל-BLOB הסתיימה בהצלחה.");
                    resolve(e.data);
                    worker.terminate();
                };

                worker.postMessage({ buffer });
            });
        }
    </script>
</body>
</html>
